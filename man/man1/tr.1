.TH TR 1
.SH NAME
tr \- translate character codes
.SH SYNOPSIS
\fBtr\fR [\fB\-cds\fR]\fR [\fIstring1\fR] [\fIstring2\fR]\fR
.br
.de FL
.TP
\\fB\\$1\\fR
\\$2
..
.de EX
.TP 20
\\fB\\$1\\fR
# \\$2
..
.SH OPTIONS
.TP 5
.B \-c
# Complement the set of characters in \fIstring1\fR
.TP 5
.B \-d
# Delete all characters specified in \fIstring1\fR
.TP 5
.B \-s
# Squeeze all runs of characters in \fIstring1\fR to one character
.SH EXAMPLES
.TP 20
.B tr \(fmA\-Z\(fm \(fma\-z\(fm <x >y
# Convert upper case to lower case
.TP 20
.B tr \-d \(fm0123456789\(fm <f1 >f2
# Delete all digits from \fIf1\fR
.SH DESCRIPTION
.PP
.I Tr
performs simple character translation.
When no flag is specified, each character in 
.I string1
is mapped onto the corresponding character in
.I string2 .
.PP
There are two types of
.I tr
out there, one that requires [ and ] for character classes, and one that does
not.  Here is what the example above would look like for a
.I tr
that needs the brackets:
.PP
.RS
.B "tr \(fm[A\-Z]\(fm \(fm[a\-z]\(fm <x >y"
.RE
.PP
Use [ and ] if you want to be portable, because a
.I tr
that doesn't need them will still accept the syntax and mindlessly
translate [ into [ and ] into ].
.PP
MINIX tr supports the following character classes: alnum, alpha, digit, lower,
upper and xdigit. If any of these keywords is encountered between backets and 
colons, it is replaced by respectively alphanumeric characters, alphabetic
characters, decimal digits, lowercase letters, uppercase letters and 
hexadecimal digits. The following are equivalent with the given examples:
.TP 20
.B tr \(fm[:upper:]\(fm \(fm[:lower:]\(fm <x >y
# Convert upper case to lower case
.TP 20
.B tr \-d \(fm[:digit:]\(fm <f1 >f2
# Delete all digits from \fIf1\fR

